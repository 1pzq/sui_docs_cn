---
title: zkLogin
description: zkLogin是Sui的一种基元，使您能够使用OAuth凭证从Sui地址发送交易，而无需公开将两者关联起来。
---

zkLogin是Sui的一种基元，它使您能够使用OAuth凭证从Sui地址发送交易，而无需公开将两者关联起来。

zkLogin设计时考虑了以下目标：

- **简化入门流程：** zkLogin使您能够使用熟悉的OAuth登录流程在Sui上进行交易，消除了处理加密密钥或记住助记词的摩擦。
- **自我托管：** zkLogin交易需要用户通过标准的OAuth登录流程进行批准，OAuth提供商不能代表用户进行交易。
- **安全性：** zkLogin是一种两因素身份验证方案：发送交易需要来自最近OAuth登录的凭据和不由OAuth提供商管理的盐。攻击者即使攻击了OAuth帐户，也不能从用户对应的Sui地址进行交易，除非它们单独攻击了盐。
- **隐私：** 零知识证明阻止第三方将Sui地址与其相应的OAuth标识符关联起来。
- **可选的已验证身份：** 用户可以选择验证用于派生特定Sui地址的OAuth标识符。这为可验证的链上身份层奠定了基础。
- **可访问性：** 由于Sui的[密码学灵活性](./transaction-auth/signatures.mdx)，zkLogin是几种原生Sui签名方案之一。它与其他Sui基元（如赞助交易和多重签名）集成。
- **严谨性：** zkLogin的代码已由两家专门从事零知识的公司进行了独立的[审计](https://github.com/sui-foundation/security-audits/blob/main/docs/zksecurity_zklogin-circuits.pdf)。用于创建通用参考字符串的公共zkLogin仪式吸引了100多名参与者的贡献。

您是希望将zkLogin集成到您的应用程序或钱包中的开发者吗？深入了解我们的[集成指南](#integration-guide)。

如果您想了解zkLogin的工作原理，包括如何生成零知识证明以及Sui如何验证zkLogin交易，请参阅[此部分](#how-zklogin-works)。

如果您对zkLogin的安全模型和隐私考虑感兴趣，请访问此[页面](#security-and-privacy)。

还有更多问题吗？请查看[FAQ部分](#faq)。

## OpenID提供商

以下表列出了可以支持zkLogin或目前正在审核中以确定它们是否可以支持zkLogin的OpenID提供商。

| Provider     | Can support? | Devnet   | Testnet  | Mainnet  |
| ------------ | ----------   | -------- | -------- | -------- |
| Facebook     | Yes          |	 Yes    |  Yes     | Yes      |
| Google       | Yes          |   Yes    |  Yes     | Yes      |
| Twitch       | Yes          |   Yes    |  Yes     | Yes      |
| Slack        | Yes          |   Yes    |  No      | No       |
| Kakao        | Yes          |   Yes    |  No      | No       |
| Apple        | Yes          |   Yes    |  No      | No       |
| RedBull      | Under review |   No     |  No      | No       |
| Microsoft    | Under review |   No     |  No      | No       |
| AWS (Tenant) | Under review |   No     |  No      | No       |
| Amazon       | Under review |   No     |  No      | No       |
| WeChat       | Under review |   No     |  No      | No       |
| Auth0        | Under review |   No     |  No      | No       |
| Okta         | Under review |   No     |  No      | No       |

## 集成指南

以下是支持zkLogin启用交易的钱包或前端应用程序必须实现的高级流程：

1. 钱包创建一个临时KeyPair。
1. 钱包提示用户完成OAuth登录流程，其中包含与临时公钥对应的随机数。
1. 在收到JWT令牌后，钱包获取零知识证明。
1. 钱包基于JWT令牌获取唯一的用户盐。OAuth主题标识符和盐可用于计算zkLogin Sui地址。
1. 钱包使用临时私钥签署交易。
1. 钱包提交交易，包括临时签名和零知识证明。

让我们深入了解具体的实现细节。

## 安装zkLogin TypeScript SDK

要在项目中使用zkLogin TypeScript SDK，请在项目根目录中运行以下命令：

```typescript
npm install @mysten/zklogin

# If you want to use the latest experimental version:
npm install @mysten/zklogin@experimental
```

## 配置与OpenID提供商的开发者账户

Sui目前支持Google、Facebook和Twitch。将来将启用更多兼容OpenID的提供商。

例如，以下TypeScript代码可用于构建用于测试的登录URL。

```typescript
const REDIRECT_URI = '<YOUR_SITE_URL>';

const params = new URLSearchParams({
	// See below for how to configure client ID and redirect URL
	client_id: $CLIENT_ID,
	redirect_uri: $REDIRECT_URL,
	response_type: 'id_token',
	scope: 'openid',
	// See below for details about generation of the nonce
	nonce: nonce,
});

const loginURL = `https://accounts.google.com/o/oauth2/v2/auth?${params}`;
```

你必须在每个提供商中配置客户端ID（`$CLIENT_ID`）和重定向URL（`$REDIRECT_URL`）：

### Google

1. 注册Google Cloud账户并访问[仪表板](https://console.cloud.google.com/home/dashboard)。
1. 选择"APIs & Services"然后选择"Credentials"，在那里可以找到客户端ID。设置重定向URL。这应该是钱包或应用程序前端。

![1](images/zklogin-google1.png '注册Google开发者账户')

_注册Google开发者账户_

![2](images/zklogin-google2.png '转到Credentials')

_转到Credentials_

![3](images/zklogin-google3.png '配置重定向URL')

_配置重定向URL_

### Facebook

1. 注册Facebook开发者账户并访问[仪表板](https://developers.facebook.com/apps/)。

1. 选择"Build your app"，然后选择"Products"，然后选择"Facebook Login"，在那里可以找到客户端ID。设置重定向URL。这应该是钱包或应用程序前端。

![1](images/zklogin-facebook1.png '注册Facebook开发者账户')

_注册Facebook开发者账户_

![2](images/zklogin-facebook2.png '转到Settings')

_转到Settings_

### Twitch

1. 注册Twitch开发者账户。访问[仪表板](https://dev.twitch.tv/console)。

1. 转到"Register Your Application"，然后选择"Application"，在那里可以找到客户端ID。设置重定向URL。这应该是钱包或应用程序前端。

![1](images/zklogin-twitch1.png "注册Twitch开发者账户")

*注册Twitch开发者账户*

![2](images/zklogin-twitch2.png "转到Console")

*转到Console*

### Kakao

1. 注册Kakao开发者账户。访问[仪表板](https://developers.kakao.com/console/app)并添加一个应用。

![1](images/zklogin-kakao1.png "向Kakao添加应用")

*向Kakao添加应用*

1. 转到"App Keys"，在那里可以找到不同平台对应的客户端ID。

- Native app key：用于通过Android或iOS SDK调用API。
- JavaScript key：用于通过JavaScript SDK调用API。
- REST API key：用于通过REST API调用API。

![2](images/zklogin-kakao2.png "找到Client ID")

*找到Client ID*

1. 切换打开"Kakao Login Activation"和"OpenID Connect Activation"。在"Product Settings"下的"Kakao Login"中设置重定向URL。这应该是钱包或应用程序前端。

![1](images/zklogin-kakao3.png "设置重定向URL")

*设置重定向URL*

### Slack

1. 注册Slack开发者账户。访问[仪表板](https://api.slack.com/apps)并转到"Create New App"，然后选择"From scratch"。

	![1](images/zklogin-slack1.png "在Slack中创建应用")

	*在Slack中创建应用*

1. 在"App Credentials"下找到Client ID和Client Secret。

	![1](images/zklogin-slack2.png "找到Client ID和Client Secret")

	*找到Client ID和Client Secret*

1. 在"Features"下的"OAuth & Permissions"中设置重定向URL。这应该是钱包或应用程序前端。

	![1](images/zklogin-slack3.png "设置重定向URL")

	*设置重定向URL*

## 获取JWT令牌

1. 生成一个临时KeyPair。按照在传统钱包中生成KeyPair的相同过程进行。详细信息请参见 [Sui SDK](https://sdk.mystenlabs.com/typescript/cryptography/keypairs)。

1. 为临时KeyPair设置过期时间。钱包决定最大时期是当前时期还是以后的时期。钱包还确定是否用户可以调整此设置。

1. 使用配置的客户端ID、重定向URL、临时公钥和随机数组装OAuth URL：这是应用程序发送给用户以完成登录流程的内容，其中包括计算的[随机数](#notations)。

```typescript
import { generateNonce, generateRandomness } from '@mysten/zklogin';

const FULLNODE_URL = 'https://fullnode.devnet.sui.io'; // replace with the RPC URL you want to use
const suiClient = new SuiClient({ url: FULLNODE_URL });
const { epoch, epochDurationMs, epochStartTimestampMs } = await suiClient.getLatestSuiSystemState();

const maxEpoch = Number(epoch) + 2; // this means the ephemeral key will be active for 2 epochs from now.
const ephemeralKeyPair = new Ed25519Keypair();
const randomness = generateRandomness();
const nonce = generateNonce(ephemeralKeyPair.getPublicKey(), maxEpoch, randomness);
```
T认证流URL可以使用 `$CLIENT_ID`、`$REDIRECT_URL` 和 `$NONCE` 构建。

对于某些提供商（在“仅认证流”中选择“是”），JWT令牌可以立即在认证流之后的重定向URL中找到。

对于其他提供商（在“仅认证流”中选择“否”），认证流只返回重定向URL中的代码（`$AUTH_CODE`）。要检索JWT令牌，需要使用“Token Exchange URL”进行额外的POST调用。

| Provider | Auth Flow URL | Token Exchange URL | Auth Flow Only |
| ----------- | ----------- | ----------- | ----------- |
| Google | `https://accounts.google.com/o/oauth2/v2/auth?client_id=$CLIENT_ID&response_type=id_token&redirect_uri=$REDIRECT_URL&scope=openid&nonce=$NONCE` | N/A | Yes |
| Facebook | `https://www.facebook.com/v17.0/dialog/oauth?client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URL&scope=openid&nonce=$NONCE&response_type=id_token` | N/A | Yes |
| Twitch | `https://id.twitch.tv/oauth2/authorize?client_id=$CLIENT_ID&force_verify=true&lang=en&login_type=login&redirect_uri=$REDIRECT_URL& response_type=id_token&scope=openid&nonce=$NONCE` | N/A | Yes |
| Kakao | `https://kauth.kakao.com/oauth/authorize?response_type=code&client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URL&nonce=$NONCE` | `https://kauth.kakao.com/oauth/token?grant_type=authorization_code&client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URL&code=$AUTH_CODE` | No |
| Apple | `https://appleid.apple.com/auth/authorize?client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URL&scope=email&response_mode=form_post&response_type=code%20id_token&nonce=$NONCE` | N/A | Yes |
| Slack | `https://slack.com/openid/connect/authorize?response_type=code&client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URL&nonce=$NONCE&scope=openid` | `https://slack.com/api/openid.connect.token?code=$AUTH_CODE&client_id=$CLIENT_ID&client_secret=$CLIENT_SECRET` | No |

## 解码JWT

在成功重定向后，身份提供商将JWT令牌作为URL参数附加（以Google流程为例）

```
http://host/auth?id_token=tokenPartA.tokenPartB.tokenPartC&authuser=0&prompt=none
```

`id_token` 参数是以编码格式的JWT令牌。您可以通过将其粘贴到 [jwt.io](https://jwt.io) 网站中来验证编码令牌的正确性并调查其结构。

要解码JWT，您可以使用类似 `jwt_decode` 的库，并将响应映射到提供的类型 `JwtPayload`：

```typescript

const decodedJwt = jwt_decode(encodedJWT) as JwtPayload;

export interface JwtPayload {
   iss?: string;
   sub?: string;  //Subject ID
   aud?: string[] | string;
   exp?: number;
   nbf?: number;
   iat?: number;
   jti?: string;
}
```

## 用户盐管理

在计算zkLogin Sui地址时使用用户盐（请参见 [定义](#address-definition)）。盐必须是一个16字节的值，或者小于`2n**128n`的整数。应用程序在维护用户盐时有几个选项：
1. 客户端端：
   - 选项1：在访问钱包时请求用户输入盐，将责任转移到用户身上，用户需要记住盐。
   - 选项2：浏览器或移动存储：确保适当的工作流程，以防止用户在更改设备或浏览器时失去钱包访问。一种方法是在设置新钱包时通过电子邮件发送盐。
2. 公开一个端点的后端服务，该端点为每个用户一致返回唯一的盐。
   - 选项3：在传统数据库中（例如 `user` 或 `password` 表）存储从用户标识符（例如 `sub`）到用户盐的映射。每个用户的盐是唯一的。
   - 选项4：实现一个服务，保留主种子值，并通过验证和解析JWT令牌派生用户盐，使用密钥派生，例如使用 `HKDF(ikm = seed, salt = iss || aud, info = sub)` 在 [这里](https://github.com/MystenLabs/fastcrypto/blob/e6161f9279510e89bd9e9089a09edc018b30fbfe/fastcrypto/src/hmac.rs#L121)定义。请注意，此选项不允许在主种子上进行旋转或更改客户端ID（即aud），否则将导致派生不同用户地址，可能会导致资金丢失。

以下是Mysten Labs维护的盐服务器的示例请求和响应（使用选项4）。如果您希望使用Mysten运行的盐服务器，请联系我们以将您注册的客户端ID列入白名单。只有使用已列入白名单的客户端ID进行身份验证的有效JWT令牌才会被接受。

```bash
curl -X POST https://salt.api.mystenlabs.com/get_salt -H 'Content-Type: application/json' -d '{"token": "$JWT_TOKEN"}'

Response: {"salt":"129390038577185583942388216820280642146"}
```

用户盐用于断开OAuth标识符（sub）与链上Sui地址之间的关联，以避免将Web2凭据与Web3凭据关联起来。尽管失去或滥用盐可能会启用此关联，但不会危及资金控制或zkLogin资产权限。请参阅更多讨论 [这里](#security-and-privacy)。

## 获取用户的Sui地址

一旦OAuth流程完成，JWT令牌可以在重定向URL中找到。结合用户盐，可以按照以下步骤派生zkLogin地址：

```typescript
import { jwtToAddress } from '@mysten/zklogin';

const zkLoginUserAddress = jwtToAddress(jwt, userSalt);
```

## 获取零知识证明

下一步是获取ZK证明。这是对临时密钥对的一种证明，证明临时密钥对是有效的。

首先，生成扩展的临时公钥，以将其用作ZKP的输入。

```typescript
import { getExtendedEphemeralPublicKey } from '@mysten/zklogin';

const extendedEphemeralPublicKey = getExtendedEphemeralPublicKey(ephemeralKeyPair.getPublicKey());
```

如果之前的临时密钥对已过期或无法访问，您需要获取一个新的ZK证明。

由于在客户端生成ZK证明可能会消耗大量资源并且潜在地较慢，建议钱包使用专用于ZK证明生成的后端服务端点。

有两个选项：
1. 调用Mysten Labs维护的证明服务
1. 在您的后端使用提供的Docker映像运行证明服务。

### 调用Mysten Labs维护的证明服务

如果您希望在Mainnet上使用Mysten运行的ZK Proving Service，请联系我们，以便将您的注册客户端ID列入白名单。仅接受使用列入白名单的客户端ID进行身份验证的有效JWT令牌。

要使用`prover-dev`端点，您无需列入白名单客户端ID。请注意，使用`prover-dev`端点生成的证明只能提交用于Devnet zkLogin交易，将其提交到Testnet或Mainnet将失败。

| 网络 | Prover URL |
| ------- | ---------- |
| Mainnet, Testnet | https://prover.mystenlabs.com/v1 |
| Devnet | https://prover-dev.mystenlabs.com/v1 |

您可以使用BigInt或Base64编码来处理 `extendedEphemeralPublicKey`，`jwtRandomness`和 `salt`。以下示例展示了两个样本请求，第一个使用BigInt编码，第二个使用Base64。

```bash
curl -X POST $PROVER_URL -H 'Content-Type: application/json' \
-d '{"jwt":"$JWT_TOKEN", \
"extendedEphemeralPublicKey":"84029355920633174015103288781128426107680789454168570548782290541079926444544", \
"maxEpoch":"10", \
"jwtRandomness":"100681567828351849884072155819400689117", \
"salt":"248191903847969014646285995941615069143", \
"keyClaimName":"sub" \
}'

curl -X POST $PROVER_URL -H 'Content-Type: application/json' \
-d '{"jwt":"$JWT_TOKEN", \
"extendedEphemeralPublicKey":"ucbuFjDvPnERRKZI2wa7sihPcnTPvuU//O5QPMGkkgA=", \
"maxEpoch":"10", \
"jwtRandomness":"S76Qi8c/SZlmmotnFMr13Q==", \
"salt":"urgFnwIxJ++Ooswtf0Nn1w==", \
"keyClaimName":"sub" \
}'
```

回应：

```json
{
	"proofPoints":{
		"a":["17267520948013237176538401967633949796808964318007586959472021003187557716854",
			"14650660244262428784196747165683760208919070184766586754097510948934669736103",
			"1"],
		"b":[["21139310988334827550539224708307701217878230950292201561482099688321320348443",
		"10547097602625638823059992458926868829066244356588080322181801706465994418281"],
		["12744153306027049365027606189549081708414309055722206371798414155740784907883",
		"17883388059920040098415197241200663975335711492591606641576557652282627716838"],
		["1","0"]],

		"c":["14769767061575837119226231519343805418804298487906870764117230269550212315249",
		"19108054814174425469923382354535700312637807408963428646825944966509611405530","1"]
		},
		"issBase64Details":{"value":"wiaXNzIjoiaHR0cHM6Ly9pZC50d2l0Y2gudHYvb2F1dGgyIiw", "indexMod4": 2 },
		"headerBase64":"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEifQ"
}
```

### 如何处理CORS错误

为了避免在前端应用中可能出现的CORS错误，建议将此调用委托给后端服务。

响应可以映射到 zkLogin SDK 的 `getZkLoginSignature` 方法的输入参数类型。

```typescript
const proofResponse = await post('/your-internal-api/zkp/get', zkpRequestPayload);

export type PartialZkLoginSignature = Omit<
	Parameters<typeof getZkLoginSignature>['0']['inputs'],
	'addressSeed'
>;
const partialZkLoginSignature = proofResponse as PartialZkLoginSignature;
```

### 在你的后端运行证明服务

1. 从  Docker Hub [仓库](https://hub.docker.com/repository/docker/mysten/zklogin/general) 下载标记为  `prover` 和 `prover-fe` 的两个镜像。
1. Download the [Groth16 proving key zkey file](https://docs.circom.io/getting-started/proving-circuits/) that will be later used as an argument to run the prover. There are zkeys available for Mainnet and Testnet, as well as a test zkey for Devnet. See [the Ceremony section](#ceremony) for more details on how the main proving key is generated. Please install [git lfs](https://git-lfs.com/) which is needed before downloading the zkey.
下载 Groth16 证明密钥 zkey 文件，从 [Groth16 proving key zkey 文件链接](https://docs.circom.io/getting-started/proving-circuits/) 下载该文件，稍后将用作运行 prover 的参数。有适用于 Mainnet 和 Testnet 的 zkeys，以及用于 Devnet 的测试 zkey。有关主证明密钥生成的详细信息，请参阅 [仪式部分](#仪式)。在下载 zkey 前，请安装 [git lfs](https://git-lfs.com/)，这是必需的。


	- Main zkey (for Mainnet and Testnet)
		```bash
		wget -O - https://raw.githubusercontent.com/sui-foundation/zklogin-ceremony-contributions/main/download-main-zkey.sh | bash
		```
	- Test zkey (for Devnet)
		```bash
		wget -O - https://raw.githubusercontent.com/sui-foundation/zklogin-ceremony-contributions/main/download-test-zkey.sh | bash
		```

	- 验证下载是否包含正确的 zkey 文件，可以运行以下命令检查 Blake2b 哈希：`b2sum ${file_name}.zkey`。

		| Network | zkey file name | Hash |
		| ------------ | ----------   | -------- |
		| Mainnet, Testnet |  `zkLogin-main.zkey` | `060beb961802568ac9ac7f14de0fbcd55e373e8f5ec7cc32189e26fb65700aa4e36f5604f868022c765e634d14ea1cd58bd4d79cef8f3cf9693510696bcbcbce` |
		| Devnet | `zkLogin-test.zkey` | `686e2f5fd969897b1c034d7654799ee2c3952489814e4eaaf3d7e1bb539841047ae8ee5fdcdaca5f4ddd76abb5a8e8eb77b44b693a2ba9d4be57e94292b26ce2` |

1. Run `prover` at `PORT1` with the downloaded zkey. This needs to be run on Linux-based machines (amd64). Further, we recommended using at least 16 vcpu, preferably an AMD cpu and at least 16gb ram for production use. Whereas 8 vcpu, 8gb ram works for testing (but its not fast).
# 在 `PORT1` 上使用下载的 zkey 运行 `prover`
在 Linux-based 机器（amd64）上运行此命令。建议在生产环境中使用至少 16 vcpu，最好是 AMD cpu，并且至少需要 16GB RAM。而在测试环境中，8 vcpu 和 8GB RAM 可以工作（但速度较慢）。

	```bash
	docker run \
	-e ZKEY=/app/binaries/zkLogin.zkey \
	-e WITNESS_BINARIES=/app/binaries \
	-v <path_to_zkLogin.zkey>:/app/binaries/zkLogin.zkey \
	-p PORT1:8080 \
	<prover-image>
	```

1. 在 `PORT2` 上运行 `prover-fe`

	```bash
	docker run \
		-e PROVER_URI='http://localhost:PORT1/input' \
		-e NODE_ENV=production \
		-e DEBUG=zkLogin:info,jwks \
		-p PORT2:8080 \
		<prover-fe-image> 8080
	```

1. 将 `prover-fe` 服务适当地暴露，同时将 prover 服务保持为内部服务。
1. 调用证明服务的两个支持的端点：
   - `/ping`：用于测试服务是否正常运行。运行 `curl http://localhost:PORT2/ping` 应返回 `pong`。
   - `/v1`：请求和响应与 Mysten Labs 维护的服务相同。


一些建议注意事项：

- 如果出于性能原因，您想从头开始编译 prover，请查看我们对 [rapidsnark](https://github.com/MystenLabs/rapidsnark#compile-prover-in-server-mode) 的分支。您需要编译并以服务器模式启动 prover。

- 设置 `DEBUG=*` 会在 prover-fe 服务中打开所有日志，其中一些可能包含个人身份信息（PII）。在生产环境中，考虑使用 `DEBUG=zkLogin:info,jwks`。

- 如果您看到错误消息 "Call to rapidsnark service took longer than 15s"，请考虑通过将环境变量 `PROVER_TIMEOUT` 设置为较高的值来增加超时时间。例如，`PROVER_TIMEOUT=30`。

## 组装 zkLogin 签名并提交交易

首先，使用先前生成的密钥对，使用临时私钥对交易字节进行签名。这与 [传统的 KeyPair 签名](https://sdk.mystenlabs.com/typescript/cryptography/keypairs) 相同。确保交易中定义了 `sender`。

```typescript
 const ephemeralKeyPair = new Ed25519Keypair();

const client = new SuiClient({ url: "<YOUR_RPC_URL>" });

const txb = new TransactionBlock();

txb.setSender(zkLoginUserAddress);

const { bytes, signature: userSignature } = await txb.sign({
   client,
   signer: ephemeralKeyPair, // This must be the same ephemeral key pair used in the ZKP request
});
```

接下来，通过组合 `userSalt`、`sub`（主题 ID）和 `aud`（受众）生成地址种子。

将地址种子和部分 zkLogin 签名设置为 `inputs` 参数。

现在，您可以通过组合 ZK 证明（`inputs`）、`maxEpoch` 和短暂签名（`userSignature`）来序列化 zkLogin 签名。

```typescript
import { genAddressSeed, getZkLoginSignature } from "@mysten/zklogin";

const addressSeed : string = genAddressSeed(BigInt(userSalt!), "sub", decodedJwt.sub, decodedJwt.aud).toString();

const zkLoginSignature : SerializedSignature = getZkLoginSignature({
   inputs: {
      ...partialZkLoginSignature,
      addressSeed
   },
   maxEpoch,
   userSignature,
});
```

最后，执行交易。

```typescript
client.executeTransactionBlock({
	transactionBlock: bytes,
	signature: zkLoginSignature,
});
```

## 缓存短暂私钥和 ZK 证明

如先前记录的，每个 ZK 证明与一个短暂密钥对相关联。因此，您可以重用该证明来签署任意数量的交易，直到短暂密钥对过期（直到当前纪元超过 `maxEpoch` 为止）。

您可能希望缓存短暂密钥对以及 ZKP 供将来使用。

但是，短暂密钥对需要像传统钱包中的密钥对一样对待为机密信息。这是因为如果短暂私钥和 ZK 证明都被泄露给攻击者，那么它们通常可以代表用户签署任何交易（使用先前描述的相同过程）。

因此，您不应该在任何平台的不安全存储位置上持久存储它们。例如，在浏览器上，使用会话存储而不是本地存储来存储短暂密钥对和 ZK 证明。

# zkLogin 工作原理

在简要概述中，zkLogin 协议依赖于以下内容：

1. JWT 令牌是来自 OAuth 提供程序的已签名有效负载，包括一个名为 nonce 的用户定义字段。zkLogin 利用 [OpenID Connect OAuth 流程](https://openid.net/developers/how-connect-works/)，将 nonce 定义为公钥和到期时期。
1. 钱包存储一个短暂 KeyPair，其中短暂公钥在 nonce 中定义。短暂私钥为短暂会话签署交易，消除了用户记忆的需要。
   基于 JWT 令牌生成 Groth16 零知识证明，隐藏了隐私敏感字段。
1. 提交具有短暂签名和 ZK 证明的交易上链。Sui 当局在验证短暂签名和证明后执行交易。
1. 与基于公钥派生 Sui 地址不同，zkLogin 地址是从 `sub`（唯一标识每个提供程序的用户）、`iss`（标识提供程序）、`aud`（标识应用程序）和 `user_salt`（将 OAuth 标识符与链上地址解除链接的值）派生的。

## 完整的 zkLogin 流程

![1](images/zklogin-flow.png 'zkLogin Complete Flow')

(步骤 0) 我们在协议的 zkSNARK 实例化中使用 Groth16，需要生成与电路相关联的结构化公共参考字符串 (CRS)。进行仪式生成 CRS，用于在 ZK 证明服务中生成证明密钥和在 Sui 当局生成验证密钥。有关详细信息，请参阅 [仪式部分](#仪式)。

(步骤 1-3) 用户首先通过登录到 OpenID 提供程序 (OP) 来获取包含定义的 nonce 的 JWT 令牌。特别是，用户生成一个 _短暂_ KeyPair `(eph_sk, eph_pk)`，并将 `eph_pk` 与到期时间 (`max_epoch`) 和随机性 (`jwt_randomness`) 一起嵌入 nonce 中（参见 [definition](#notations)）。用户完成 OAuth 登录流程后，在应用程序的重定向 URL 中可以找到 JWT 令牌。

(步骤 4-5) 然后，应用程序前端将 JWT 令牌发送到 salt 服务。salt 服务在验证 JWT 令牌后，基于 `iss, aud, sub` 返回唯一的 `user_salt`。

(步骤 6-7) 用户将 JWT 令牌、用户 salt、短暂公钥、jwt 随机性、密钥声明名称（即 `sub`）发送给 ZK 证明服务。证明服务生成一个零知识证明，将这些作为私有输入，并执行以下操作：(a) 检查 nonce 是否正确派生 [如定义](#notations) (b) 检查密钥声明值是否与 JWT 中的相应字段匹配，(c) 验证来自 OP 的 JWT 的 RSA 签名，以及 (d) 地址是否与密钥声明值和用户 salt 一致。

(步骤 8): 应用程序基于 iss, aud, sub, aud 计算用户地址。只要应用程序具有有效的 JWT 令牌，可以独立执行此步骤。

(步骤 9-10) 使用短暂私钥签署交易以生成短暂签名。最后，用户将交易与短暂签名、ZK 证明和其他输入一起提交给 Sui。

(步骤 10 之后) 在链上提交后，Sui 当局使用存储中的提供程序 JWK 验证 ZK 证明，并验证短暂签名。

## 实体

1. 应用程序前端：描述支持 zkLogin 的钱包或前端应用程序。该前端负责存储短暂私钥，引导用户完成 OAuth 登录流程，创建和签署 zkLogin 交易。

2. Salt 备份服务：负责返回每个唯一用户的盐。有关维护盐的其他策略，请参阅 [集成指南](#integration-guide)。

3. ZK 证明服务：负责基于 JWT 令牌、JWT 随机性、用户 salt 和最大纪元生成 ZK 证明的后端服务。此证明与 zkLogin 交易的短暂签名一起提交到链上。

## 地址定义

地址是根据以下输入计算的：

1. 地址标志：`zk_login_flag = 0x05` 用于 zkLogin 地址。这充当 [密码敏捷性](./transaction-auth/signatures.mdx) 中定义的签名方案的域分隔符。

1. `kc_name_F = hashBytesToField(kc_name, maxKCNameLen)`：密钥声明的名称，例如 `sub`。使用 `hashBytesToField` 将字节序列映射到 BN254 中的字段元素（下文定义）。

1. `kc_value_F = hashBytesToField(kc_value, maxKCValueLen)`：密钥声明的值，使用 `hashBytesToField` 映射。

1. `aud_F = hashBytesToField(aud, maxAudValueLen)`：依赖方 (RP) 标识符。请参阅 [定义](#术语和符号)。

1. `iss`：OpenID 提供程序 (OP) 标识符。请参阅 [定义](#术语和符号)。

1. `user_salt`：用于解除 OAuth 标识符与链上地址的关联的值。

最后，我们派生 `zk_login_address = Blake2b_256(zk_login_flag, iss_L, iss, addr_seed)`，其中 `addr_seed = Poseidon_BN254(kc_name_F, kc_value_F, aud_F, Poseidon_BN254(user_salt)`。

## 术语和符号

下面是在 [规范](https://openid.net/specs/openid-connect-core-1_0.html#Terminology) 中定义的所有相关 OpenID 术语，以及它们在 zkLogin 中的使用，以及协议详细信息的定义。

### OpenID 提供程序 (OP)

能够对最终用户进行身份验证并向依赖方提供有关身份验证事件和最终用户的声明的 OAuth 2.0 授权服务器。在 JWT 令牌负载中通过 `iss` 字段标识。当前 zkLogin 支持的 OP 包括 Google、Facebook 和 Twitch，将来将启用更多兼容的提供程序。

### 依赖方 (RP) 或客户端

需要最终用户身份验证和来自 OpenID 提供程序的声明的 OAuth 2.0 客户端应用程序。由开发人员创建应用程序时由 OP 分配。在 JWT 令牌负载中通过 `aud` 字段标识。这指的是任何支持 zkLogin 的钱包或应用程序。

### 主题标识符 (sub)

在颁发者内部唯一且永不重新分配的最终用户标识符，旨在由 RP 消耗。Sui 将其用作导出用户地址的密钥声明。

### JWK (JSON Web Key)

表示 OP 的一组公钥的 JSON 数据结构。可以查询公共端点（例如 https://www.googleapis.com/oauth2/v3/certs）以检索与提供程序的 `kid` 对应的有效公钥。与 JWT 令牌头部中的 `kid` 匹配后，可以根据负载及其相应的 JWK 验证 JWT 令牌。在 Sui 中，所有当局独立调用 JWK 端点，并在协议升级期间更新所有支持的提供程序的最新 JWK 视图。JWK 的正确性由验证者的法定数量（2f+1）保证。

### JWT 令牌 (JSON Web Token)

JWT 令牌可以在用户完成 OAuth 登录流程后在 RP 的重定向 URL 中找到（即 `https://redirect.com?id_token=$JWT_TOKEN`）。JWT 令牌包含一个 `header`、`payload` 和一个 `signature`。签名是可以根据 `jwt_message = header + . + payload` 及其由 `kid` 标识的 JWK 验证的 RSA 签名。`payload` 包含许多声明的 JSON，是名称-值对。请参阅下文，了解与 zkLogin 协议相关的特定声明。

**Header**

| Name | Example Value                            | Usage                                                     |
| ---- | ---------------------------------------- | --------------------------------------------------------- |
| alg  | RS256                                    | zkLogin only supports `RS256` (RSA + SHA-256).            |
| kid  | c3afe7a9bda46bae6ef97e46c95cda48912e5979 | Identifies the JWK that should be used to verify the JWT. |
| typ  | JWT                                      | zkLogin only supports `JWT`.                              |

**Payload**

| Name  | Example Value                                                            | Usage                                                                                                                                                      |
| ----- | ------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| iss   | https://accounts.google.com                                              | A unique identifier assigned to the OAuth provider.                                                                                                        |
| aud   | 575519200000-msop9ep45u2uo98hapqmngv8d8000000.apps.googleusercontent.com | A unique identifier assigned to the relying party by the OAuth provider.                                                                                   |
| nonce | hTPpgF7XAKbW37rEUS6pEVZqmoI                                              | A value set by the relying party. The zkLogin enabled wallet is required to set this to the hash of ephemeral public key, an expiry time and a randomness. |
| sub   | 110463452167303000000                                                    | A unique identifier assigned to the user.                                                                                                                  |

For a zkLogin transaction, we do not use the `iat` and `exp` claims (i.e., timestamp). This is because we provide a different way for users to specify expiry times, namely via `nonce`.

### Key Claim

We call the claim used to derive a users' address as the "key claim" e.g., sub or email. Naturally, we only want to use claims that are fixed once and never changed again. For zkLogin, we currently support sub as the key claim because OpenID spec mandates that providers do not change this identifier. In the future, this can be extended to use email, username, etc.

### Notations

1. `(eph_sk, eph_pk)`: Ephemeral key pair refers to the private and public key pair used to produce ephemeral signatures. The signing mechanism is the same as traditional transaction signing, but it is ephemeral because it is only stored for a short session and can be refreshed upon new OAuth sessions. The ephemeral public key is used to compute nonce.
2. `nonce`: An application-defined field embedded in the JWT token payload, computed as the hash of the ephemeral public key, JWT randomness, and the maximum epoch (Sui's defined expiry epoch). Specifically, a zkLogin compatible nonce is required to passed in as `nonce = ToBase64URL(Poseidon_BN254([ext_eph_pk_bigint / 2^128, ext_eph_pk_bigint % 2^128, max_epoch, jwt_randomness]).to_bytes()[len - 20..])` where `ext_eph_pk_bigint` is the BigInt representation of `ext_eph_pk`.
3. `ext_eph_pk`: The byte representation of an ephemeral public key (`flag || eph_pk`). Size varies depending on the choice of the signature scheme (denoted by the flag, defined in [Signatures](./transaction-auth/signatures.mdx)).
4. `user_salt`: A value introduced to unlink the OAuth identifier with the on-chain address.
5. `max_epoch`: The epoch at which the JWT token expires. This is u64 used in Sui.
6. `kc_name`: The key claim name, e.g. `sub`.
7. `kc_value`: The key claim value, e.g. `110463452167303000000`.
8. `hashBytesToField(str, maxLen)`: Hashes the ASCII string to a field element using the Poseidon hash.

## Ceremony

To preserve privacy of the OAuth artifacts, a zero-knowledge proof of possession of the artifacts is provided. zkLogin employs the Groth16 zkSNARK to instantiate the zero-knowledge proofs, as it is the most efficient general-purpose zkSNARK in terms of proof size and verification efficiency.

However, Groth16 needs a computation-specific Common Reference String (CRS) to be setup by a trusted party. With zkLogin expected to ensure the safe-keeping of high value transactions and the integrity of critical smart contracts, we cannot base the security of the system on the honesty of a single entity. Hence, to generate the CRS for the zkLogin circuit, it is vital to run a protocol which bases its security on the assumed honesty of a small fraction of a large number of parties.

### What is the ceremony?

The Sui zkLogin ceremony is essentially a cryptographic multi-party computation (MPC) performed by a diverse group of participants to generate this CRS. We follow the MPC protocol [MMORPG](https://eprint.iacr.org/2017/1050.pdf) described by Bowe, Gabizon and Miers. The protocol roughly proceeds in 2 phases. The first phase results in a series of powers of a secret quantity tau in the exponent of an elliptic curve element. Since this phase is circuit-agnostic, we adopted the result of the existing community contributed [perpetual powers of tau](https://github.com/privacy-scaling-explorations/perpetualpowersoftau/tree/master). Our ceremony was the second phase, which is specific to the zkLogin circuit.

The MMORPG protocol is a sequential protocol, which allows an indefinite number of parties to participate in sequence, without the need of any prior synchronization or ordering. Each party needs to download the output of the previous party, generate entropy of its own and then layer it on top of the received result, producing its own contribution, which is then relayed to the next party. The protocol guarantees security, if at least one of the the participants follows the protocol faithfully, generates strong entropy and discards it reliably.

### How was the ceremony performed?

We sent invitations to 100+ people with diverse backgrounds and affiliations: Sui validators, cryptographers, web3 experts, world-renowned academicians, and business leaders. We planned the ceremony to take place on the dates September 12-18, 2023, but allowed participants to join when they wanted with no fixed slots.

Since the MPC is sequential, each contributor needed to wait till the previous contributor finished in order to receive the previous contribution, follow the MPC steps and produce their own contribution. Due to this structure, we provisioned a queue where participants waited, while those who joined before them finished. To authenticate participants, we sent a unique activation code to each of them. The activation code was the secret key of a signing key pair, which had a dual purpose: it allowed the coordination server to associate the participant's email with the contribution, and to verify the contribution with the corresponding public key.

Participants had two options to contribute: through a browser or a docker. The browser option was more user-friendly for contributors to participate as everything happens in the browser. The Docker option required Docker setup but is more transparent—the Dockerfile and contributor source code are open-sourced and the whole process is verifiable. Moreover, the browser option utilizes [snarkjs](https://github.com/iden3/snarkjs) while the Docker option utilizes [Kobi's implementation](https://github.com/iseriohn/phase2-bn254). This provided software variety and contributors could choose to contribute by whichever method they trust. In addition, participants could generate entropy via entering random text or making random cursor movements.

The zkLogin circuit and the ceremony client [code](https://github.com/sui-foundation/zk-ceremony-client) were made open source and the links were made available to the participants to review before the ceremony. In addition, we also posted these developer docs and an [audit report](https://github.com/sui-foundation/security-audits/blob/main/docs/zksecurity_zklogin-circuits.pdf) on the circuit from zkSecurity. We adopted [challenge #0081](https://pse-trusted-setup-ppot.s3.eu-central-1.amazonaws.com/challenge_0081) (resulting from 80 community contributions) from [perpetual powers of tau](https://github.com/privacy-scaling-explorations/perpetualpowersoftau/tree/master/0080_carter_response) in phase 1, which is circuit agnostic. We applied the output of the [Drand](http://drand.love) random beacon at epoch #3298000 to remove bias. For phase 2, our ceremony had 111 contributions, 82 from browser and 29 from docker. Finally, we applied the output of the Drand random beacon at epoch #3320606 to remove bias from contributions. All intermediate files can be reproduced following instructions [here](https://github.com/sui-foundation/zklogin-ceremony-contributions/blob/main/phase1/README.md) for phase 1 and [here](https://github.com/sui-foundation/zklogin-ceremony-contributions/blob/main/phase2/README.md) for phase 2.

## Finalization

The final CRS along with the transcript of contribution of every participant is available in a public repository. Contributors received both the hash of the previous contribution they were working on and the resulting hash after their contribution, displayed on-screen and sent via email. They can compare these hashes with the transcripts publicly available on the ceremony site. In addition, anyone is able to check that the hashes are computed correctly and each contribution is properly incorporated in the finalized parameters.

Eventually, the final CRS was used to generate the proving key and verifying key. The proving key is used to generate zero knowledge proof for zkLogin, stored with the ZK proving service. The verifying key was [deployed](https://github.com/MystenLabs/sui/pull/13822) as part of the validator software (protocol version 25 in [release 1.10.1](https://github.com/MystenLabs/sui/releases/tag/mainnet-v1.10.1)) that is used to verify the zkLogin transaction on Sui.

## Security and Privacy

We'll walk through all zkLogin artifacts, their security assumptions, and the consequences of loss or exposure.

## JWT Token

The JWT token's validity is scoped on the client ID (i.e. aud) to prevent phishing attacks. The same origin policy for the proof prevents the JWT token obtained for a malicious application from being used for zkLogin. The JWT token for the client ID is sent directly to the application frontend through the redirect URL. A leaked JWT token for the specific client ID can compromise user privacy, as these tokens frequently hold sensitive information like usernames and emails. Furthermore, if a backend salt server is responsible for user salt management, the JWT token could potentially be exploited to retrieve the user's salt, which introduces additional risks.

However, a JWT leak does not mean loss of funds as long as the corresponding ephemeral private key is safe.

## User Salt

The user salt is required to get access to the zkLogin wallet. This value is essential for both ZK proof generation and zkLogin address derivation.

The leak of user salt does not mean loss of funds, but it enables the attacker to associate the user's subject identifier (i.e. `sub`) with the Sui address. This can be problematic depending on whether pairwise or public subject identifiers are in use. In particular, there is no problem if pairwise IDs are used (e.g., Facebook) as the subject identifier is unique per RP. However, with public reusable IDs (e.g., Google and Twitch), the globally unique sub value can be used to identify users.

## Ephemeral Private Key

The ephemeral private key's lifespan is tied to the maximum epoch specified in nonce for creating a valid ZK proof. Should it be misplaced, a new ephemeral private key can be generated for transaction signing, accompanied by a freshly generated ZK proof using a new nonce. However, if the ephemeral private key is compromised, acquiring the user salt and the valid ZK proof would be necessary to move funds.

## Proof

Obtaining the proof itself cannot create a valid zkLogin transaction because an ephemeral signature over the transaction is also needed.

## Privacy

By default, there is no linking between the OAuth subject identifier (i.e. `sub`) and a Sui address. This is the purpose of the user salt.
The JWT token is not published on-chain by default. The revealed values include `iss`, `aud` and `kid` so that the public input hash can be computed, any sensitive fields such as `sub` are used as private inputs when generating the proof.

The ZK proving service and the salt service (if maintained) can link the user identity since the user salt and JWT token are known, but the two services are stateless by design.

In the future, the user can opt in to verify their OAuth identity associated with an Sui address on-chain.

## FAQ

### What providers is zkLogin compatible with?

zkLogin can support providers that work with OpenID Connect built on top of the OAuth 2.0 framework. This is a subset of OAuth 2.0 compatible providers. Sui currently supports Google, Facebook and Twitch. Other compatible providers will be enabled via protocol upgrades in the future.

### How is a zkLogin Wallet different from a traditional private key wallet?

Traditional private key wallets demand users to consistently recall mnemonics and passphrases, necessitating secure storage to prevent fund loss from private key compromise.

On the other hand, a zkLogin wallet only requires an ephemeral private key storage with session expiry and the OAuth login flow with expiry. Forgetting an ephemeral key does not result in loss of funds, because a user can always sign in again to generate a new ephemeral key and a new ZK proof.

### How is zkLogin different from MPC or Multisig wallets?

Multi-Party Computation (MPC) and Multisig wallets rely on multiple keys or distributing multiple key shares and then defining a threshold value for accepting a signature.

zkLogin does not split any individual private keys, but ephemeral private keys are registered using a fresh nonce when the user authenticates with the OAuth provider. The primary advantage of zkLogin is that the user does not need to manage any persistent private key anywhere, not even with any private keys management techniques like MPC or Multisig.

You can think of zkLogin as a 2FA scheme for an address, where the first part is user's OAuth account and the second is the user's salt.

Furthermore, because Sui native supports Multisig wallets, one can always include one or more zkLogin signers inside a Multisig wallet for additional security, such as using the zkLogin part as 2FA in k-of-N settings.

### If my OAuth account is compromised, what happens to my zkLogin address?

Because zkLogin is a 2FA system, an attacker that has compromised your OAuth account cannot access your zkLogin address unless they have separately compromised your salt.

### If I lose access to my OAuth account, do I lose access to my zkLogin address?

Yes. You must be able to log into your OAuth account and produce a current JWT in order to use zkLogin.

### Does losing my OAuth credential mean the loss of funds in the zkLogin wallet?

A forgotten OAuth credential can typically be recovered by resetting the password in that provider.
In the unfortunate event where user's OAuth credentials get compromised, an adversary will still require to obtain `user_salt`, but also learn which wallet is used in order to take over that account. Note that modern `user_salt` providers may have additional 2FA security measures in place to prevent provision of user's salt even to entities that present a valid, non-expired JWT.

It's also important to highlight that due to the fact that zkLogin addresses do not expose any information about the user's identity or wallet used, targeted attacks by just monitoring the blockchain are more difficult.
Finally, on the unfortunate event where one loses access to their OAuth account permanently, access to that wallet is lost. But if recovery from a lost OAuth account is desired, a good suggestion for wallet providers is to support the native Sui Multisig functionality and add a backup method. Note that it's even possible to have a Multisig wallet that all signers are using zkLogin, i.e. an 1-of-2 Multisig zkLogin wallet where the first part is Google and the second Facebook OAuth, respectively.

### Can I convert or merge a traditional private key wallet into a zkLogin one, or vice versa?

No. The zkLogin wallet address is derived differently compared to a private key address.

### Will my zkLogin address ever change?

zkLogin address is derived from `sub`, `iss`, `aud` and `user_salt`.

The address will not change if the user logs in to the same wallet with the same OAuth provider, since `sub`, `iss`, `aud` and `user_salt` (see definitions) will remain unchanged in the JWT token, even though the JWT token itself may look different every time the user logs in.

However, if the user logs in with different OAuth providers, your address will change because the `iss` and `aud` are defined distinctly per provider.

In addition, each wallet or application maintains its own `user_salt`, so logging with the same provider for different wallets may also result in different addresses.

See more on address [definition](#address-definition).

### Can I have multiple addresses with the same OAuth provider?

Yes, this is possible by using a different wallet provider or different `user_salt` for each account. This is useful for separating funds between different accounts.

### Is a zkLogin Wallet custodial?

A zkLogin wallet is a non-custodial or unhosted wallet.

A custodial or hosted wallet is where a third party (the custodian) controls the private keys on behalf of a wallet user. No such third-party exists for zkLogin wallets.

Instead, a zkLogin wallet can be viewed as a 2-out-of-2 Multisig where the two credentials are the user's OAuth credentials (maintained by the user) and the salt. In other words, neither the OAuth provider, the wallet vendor, the ZK proving service or the salt service provider is a custodian.

### Generating a ZK proof is expensive, is a new proof required to be generated for every transaction?

No. Proof generation is only required when ephemeral KeyPair expires. Since the nonce is defined by the ephemeral public key (`eph_pk`) and expiry (`max_epoch`), the ZK proof is valid until what the expiry is committed to nonce in the JWT token. The ZK proof can be cached and the same ephemeral key can be used to sign transactions till it expires.

### Does zkLogin work on mobile?

zkLogin is a Sui native primitive and not a feature of a particular application or wallet. It can be used by any Sui developer, including on mobile.

### Is account recovery possible if the user loses the OAuth credentials?

Yes, the user can follow the OAuth providers' recovery flow. The ephemeral private key can be refreshed and after completing a new OAuth login flow, the user can obtain new ZK proof and sign transactions with the refreshed key.

### What are some assumptions for the zkLogin circuit?

Due to the way Groth16 works, we impose length restrictions on several fields in the JWT. Some of the fields that are length-restricted include aud, iss, the JWT's header and payload. For example, zkLogin can currently only work with aud values of up to length 120 (this value is not yet final). In general, we tried to make sure that the restrictions are as generous as possible. We have decided on these values after looking at as many JWTs that we could get our hands on.

### How is zkLogin different from other solutions that support social login?

While providing social login with Web2 credentials for Web3 wallet is not a new concept, the existing solutions have one or more of the trust assumptions:

1. Trust a different network or parties to verify Web2 credentials other than the Blockchain itself, usually involving a JWK oracle posted on-chain by a trusted party.
1. Trust some parties to manage a persistent private key, whether it uses MPC, threshold cryptography or secure enclaves.
1. Relying on smart contracts (account abstraction) to verify the JWT token on-chain with revealing privacy fields, or to verify ZK proofs on-chain which can be expensive.

Some of the existing deployed solutions rely on some of these assumptions. Web3Auth and DAuth social login requires deployment of custom OAuth verifiers to Web3auth Auth Network nodes to verify the JWT token. Magic Wallet and Privy also require custom OAuth identity issuer and verifiers to adopt the DID standard. All of the solutions still require persistent private keys management, either with trusted parties like AWS via delegation, Shamir Secret Sharing or MPC.

The key differentiators that zkLogin brings to Sui are:

1. Native Support in Sui: Unlike other solutions that are blockchain agnostic, zkLogin is deployed just for Sui. This means a zkLogin transaction can be combined with Multisig and sponsored transactions seamlessly.

2. Self-Custodial without additional trust: We leverage the nonce field in JWT token to commit to ephemeral public key, so no persistent private key management is required with any trusted parties. In addition, the JWK itself is an oracle agreed upon by the quorum of stakes by the validators with trusting any source of authority.

3. Full privacy: Nothing is required to submit on-chain except the ZK proof and the ephemeral signature.

4. Compatible with Existing Identity Providers: zkLogin is compatible with providers that adopt OpenID Connect. No need to trust any intermediate identity issuers or verifiers other than the OAuth providers themselves.

## How to verify a zkLogin signature offchain?

The following options support a zkLogin signature over either transaction data or personal message.

1. Use keytool: See usage in keytool.

```bash
$SUI_BINARY keytool zk-login-sig-verify -h
```

2. Use a self hosted server endpoint: See usage in [zklogin-verifier](https://github.com/MystenLabs/zklogin-verifier).
